<?xml version="1.0" encoding="UTF-8"?>
<gos>
	<!-- xml docs : http://golangserver.com/docs/markup.html -->
	<deploy>webapp</deploy>
	<port>9001</port>
	<package>if-package-is-library</package>
	<not_found>/your-404-page</not_found>
	<error>/your-500-page</error>

	<output>application.go</output>
	<domain></domain><!-- Cookie domain -->
	<var type="*MegaConfig">Config</var>
	<var type="TrLock">GL</var>
	<import src="github.com/cheikhshift/momentum/gos.gxml"/>
	<import src="strings"/>
	<import src="math/rand"/>
	<import src="sync"/>
	<import src="github.com/cheikhshift/gos/core"/>
	<import src="flag"/>
	<import src="os"/>
	<main>	
		
	 	nobrowser := flag.Bool("nobrowser", false, "Launch without openning browser")
	 	worker := flag.Bool("worker", false, "Launch megalith instance as worker")
	 	dispaddr := flag.String("dispatcher", DefaultAddress, "Host name of dispatcher instance. Add port number as needed. ie hostname:9000")
	 	workaddr := flag.String("hostname", DefaultAddress, "Host name of worker instance. Add port number as needed. ie hostname:9000")
	 	portNumber := flag.String("port", DefaultPort, "The port number megalith will to listen on") 
	 	fws := flag.String("workspace", "megaWorkSpace", "Set instance directory") 

	    flag.Parse()
	 	WorkerMode = *worker
	 	DispatcherAddressPort = *dispaddr
	 	WorkerAddressPort = *workaddr
	 	megaWorkspace = *fws
	 	if *portNumber != DefaultPort {
	 		os.Setenv(PORT, *portNumber)
	 	}

		ChdirHome()

		GL = TrLock{Lock: new (sync.RWMutex)}
		
		if !WorkerMode {
			InitConfigLoad()
			if !*nobrowser {
				LaunchBrowser()
			}
			if WorkerAddressPort != DefaultAddress {
				RegisterWorker(WorkerAddressPort)
			}
	    	ticker := time.NewTicker(Checkinterval)
		    go MegaTimer(ticker)
		} else {
			SelfAnnounce(*dispaddr)
			Config = &MegaConfig{}
		}
		
	

	</main>


	<key>a very very very very secret key</key>
	
	<header> 
		<struct name="MegaConfig">
		 	Mail MailSettings
		 	Servers []Server
		 	Cl Clock
		 	Contacts []Contact
		 	SMS TwilioInfo
		 	Misc Settings
		 	LastReset int64
		</struct>
		<struct name="TrLock">
		 	Lock  *sync.RWMutex
		</struct>
		<struct name="Server">
		 	Host,Image,Nickname string
		 	Endpoints []Endpoint
		 	Live bool
		 	ID string
		 	Uptime float64
		</struct>
		<struct name="Endpoint">
		 	Uptime float64
		 	Method, Path,Headers,Data string
		 	Timeout time.Duration
		 	ID string
		</struct>
		<struct name="RequestLog">
		 	Requests []Request
		</struct>
		<struct name="Request">
		 	Code int
		 	Owner string
		</struct>
		<struct name="Contact">
		 	Nickname,Email string
		 	Threshold float64
		 	Watching []string
		 	ID,Phone string
		</struct>
		<struct name="MailSettings">
		 	Email,Password,Host,Port string
		</struct>
		<struct name="Settings">
		 	ResetInterval int64
		</struct>
		<struct name="Clock">
		 	Interval int
		</struct>

		<struct name="TwilioInfo">
			Token,SID, From,CountryCode string
		</struct>

	</header>
	<methods>
			<func name="Mega" var="" return="(result *MegaConfig)">
				GL.Lock.Lock()
				if WorkerAddressPort != DefaultAddress {
					LoadConfig(&Config)
				}
				GL.Lock.Unlock()
				return Config
			</func>
			<func name="AddServer" var="" return="(result []Server)">
				GL.Lock.Lock()
				randint := rand.Intn(200) + 50 + len(Config.Servers) 
				genimage := fmt.Sprintf("https://picsum.photos/%v/%v",randint, randint)
				ns := Server{ID : core.NewLen(20), Nickname:"New server",Image : genimage}
				Config.Servers = append(Config.Servers, ns)
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return Config.Servers
			</func>

			<func name="DServer" var="req Server" return="(result []Server)">
				result = []Server{}
				GL.Lock.Lock()
				for _,target := range Config.Servers {
					if target.ID != req.ID {
						result = append(result, target)
					}
				}
				DeleteLog(req.ID)
				Config.Servers = result
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return
			</func>
		    <func name="UServer" var="req Server" return="(result bool)">
				GL.Lock.Lock()
				for index,target := range Config.Servers {
					if target.ID == req.ID {
						Config.Servers[index] = req
					}
				}
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return true
			</func>

			<!-- contact funcs -->
			<func name="AddContact" var="" return="(result []Contact)">
				GL.Lock.Lock()
				nc := Contact{ID : core.NewLen(20), Nickname:"New contact"}
				Config.Contacts = append(Config.Contacts, nc)
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return Config.Contacts
			</func>

			<func name="GetLog" var="req Server" return="(result RequestLog)">
				GL.Lock.Lock()
				LoadLog(req.ID, &result)
				GL.Lock.Unlock()
				return
			</func>

			<func name="DContact" var="req Contact" return="(result []Contact)">
				result = []Contact{}
				GL.Lock.Lock()
				for _,target := range Config.Contacts {
					if target.ID != req.ID {
						result = append(result, target)
					}
				}
				
				Config.Contacts = result
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return
			</func>
		    <func name="UContact" var="req Contact" return="(result bool)">
		    	GL.Lock.Lock()
				for index,target := range Config.Contacts {
					if target.ID == req.ID {
						Config.Contacts[index] = req
					}
				}
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return true
			</func>

			<!-- setting funcs -->
			<func name="UMail" var="req MailSettings" return="(result bool)">
				GL.Lock.Lock()
				Config.Mail = req
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return true
			</func>

			<func name="UTw" var="req TwilioInfo" return="(result bool)">
				GL.Lock.Lock()
				Config.SMS = req
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return true
			</func>
			<func name="USetting" var="req Settings" return="(result bool)">
				GL.Lock.Lock()
				Config.Misc = req
				Config.LastReset = time.Now().Unix()
				GL.Lock.Unlock()
				SaveConfig(&Config);
				return true
			</func>

			<func name="ProcessServer" var="req string" return="(result bool)">		
				LoadConfig(&Config)
				server,index := FindServer(req)
				Process(server,index)
				return true
			</func>

			<func name="UpdateServer" var="req Server" return="(result bool)">
				LoadConfig(&Config)
				GL.Lock.Lock()
				_,index := FindServer(req.ID)
				Config.Servers[index].Uptime = req.Uptime
				GL.Lock.Unlock()
				SaveConfig(&Config)	
				return true
			</func>

			<func name="RegisterServer" var="req string" return="(result bool)">
				RegisterWorker(req)
				return true
			</func>

	</methods>

	<templates>

	</templates>
	<endpoints>

			<end path="/" type="f" >
				if strings.Contains(r.URL.Path, ".map") || strings.Contains(r.URL.Path, "web/{{ server.Image }}") {
					return true
				}
			</end>

			<!-- Deploy endpoints as functions by updating
			this configuration file's deploy tag from 'webapp' to  'faas'.
			Find more information about gos FaaS deployments here : 
			http://gophersauce.com/docs/markup.html -->
			<end path="/update/server" type="POST" >
				type PayloadOfRequest struct {
					req string
				}
				decoder := json.NewDecoder(r.Body)
				var tmvv PayloadOfRequest
				err := decoder.Decode(&tmvv)
				if err != nil {
					w.WriteHeader(http.StatusInternalServerError)
					w.Write([]byte(fmt.Sprintf("{\"error\":\"%s\"}", err.Error())))
					return true
				}
				_ = NetProcessServer(tmvv.req)
				w.Header().Set("Content-Type", "text/plain")
				w.Write(OK)
			</end>

			<end path="/mega" type="POST" >
				
				Cfg := &MegaConfig{}
				LoadConfig(&Config) 
				w.Header().Set("Content-Type", "application/json")
				retjson := []byte(mResponse(Cfg))
				w.Write(retjson)
				retjson = nil
			</end>
			<!-- End Faas functions -->
  
	</endpoints>
</gos>
